import carla
# import queue


class Recorder:
    name = "class to record carla's sensors"

    def __init__(self, world):
        self.world = world
        self.memory_time = 10
        self.last_rec_frame = None
        self.current_frame = None
        self.sensor_names = ['depth']
        self.images = {}
        self.last_rec = {}
        self.current_rec = {}
        self.sensors = {}
        for sensor_name in self.sensor_names:
            self.set_sensor(sensor_name=sensor_name)

    def set_sensor(self, sensor_name):
        # Find the blueprint of the sensor.
        blueprint = self.world.world.get_blueprint_library().find('sensor.camera.' + sensor_name)
        # Modify the attributes of the blueprint to set image resolution and field of view.
        # blueprint.set_attribute('image_size_x', str(1600))
        # blueprint.set_attribute('image_size_y', str(1600))
        blueprint.set_attribute('fov', '170')
        blueprint.set_attribute('sensor_tick', str(1/self.world.fps))
        # Provide the position of the sensor relative to the vehicle.
        transform = carla.Transform(carla.Location(x=2, z=1.7))
        # Tell the world to spawn the sensor, don't forget to attach it to your vehicle actor.
        self.sensors[sensor_name] = self.world.world.spawn_actor(blueprint, transform, attach_to=self.world.vehicle)
        # Subscribe to the sensor stream by providing a callback function, this function is
        # called each time a new image is generated by the sensor.
        self.images[sensor_name] = []
        if self.sensors[sensor_name] is not None:
            self.sensors[sensor_name].listen(
                lambda image: self.get_rec(
                    image,
                    sensor_name=sensor_name
                )
            )

    def destroy(self):
        for sensor_name in self.sensors:
            self.sensors[sensor_name].destroy()
        self.last_rec_frame = 0

    def get_rec(self, image, sensor_name):
        self.images[sensor_name].append(image)
        i = 0
        while (self.images[sensor_name][-1].timestamp - self.images[sensor_name][i].timestamp) > self.memory_time:
            i += 1
        self.images[sensor_name] = self.images[sensor_name][i:]
        if self.images["depth"] is not None and self.images["depth"]:
            if sensor_name == "depth":
                self.last_rec = {
                    "depth": image
                }
                self.last_rec_frame = image.frame_number
            else:
                raise Exception("sensor_name : %s doesnt exist", sensor_name)
        try:
            self.world.occupancy_mapper.clean_old_frame()
        except Exception as e:
            print(e)

    def get_frame(self):
        self.current_frame = self.last_rec_frame
        self.current_rec = self.last_rec
